1.https://leetcode.com/problems/move-zeroes/description/
  int start = 0;
        int end = 0;
        while(start < nums.size()){
            if(nums[start] == 0){
                start++;
            }
            else{
                swap(nums[start], nums[end]);
                start++;
                end++;
            }}
            

2.https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/description/

                     //    int y=it.second;
                    //    c+=(y/3);
                    //    if(y%3!=0)
                    //    c+=1;
                    or
                        c+=ceil(it.second/3.0);
                     or
                        // c+=(y+2)/3;
                        
3.https://www.codingninjas.com/codestudio/problems/number-of-subsets_3952532?source=youtube&campaign=
striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=1

RECURSION
#include <bits/stdc++.h> 
int f(vector<int> &num, int tar,int sum,int i)
{
    if(sum==tar)
    {
        return 1;
    }
    if(i<0 || sum>tar)
        return 0;
    int np=f(num,tar,sum,i-1);
    int y=(sum+num[i]);
    int p=f(num,tar,y,i-1);
    return np+p;
}
int findWays(vector<int> &num, int tar)
{
    int n=num.size();
    int sum=0;
    return f(num,tar,sum,n-1);
    // Write your code here.
}

MEMOISATION
int f(vector<int> &num, int tar,int sum,int i,vector<vector<int>>& dp)
{
    if(sum>tar)
        return 0;
    if(i<0 )
        return (sum==tar);
    if(dp[i][sum]!=-1)
        return dp[i][sum];
    int np=f(num,tar,sum,i-1,dp);
    int y=(sum+num[i]);
    int p=f(num,tar,y,i-1,dp);
    return dp[i][sum]=(np+p);
}
int findWays(vector<int> &num, int tar)
{
   
    int n=num.size();
    int s=accumulate(num.begin(),num.end(),0);
     vector<vector<int>> dp(n,vector<int> (tar+1,-1));
    int sum=0;
    return f(num,tar,sum,n-1,dp);
    // Write your code here.
}
keep a check of  [1,0,2,0,3] tar=3  ,ans:0,3 and 3 and 0,3 ....8 ans possible
