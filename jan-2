https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/


Time Complexity => O(NlogN)
Space Complexity => O(1)

 
bool sc( vector<int>& v1,  vector<int>& v2)
{
    return v1[1] < v2[1];
}
class Solution {
public:

    int findMinArrowShots(vector<vector<int>>& p) {
        int n=p.size();
        if(n==0)
        return 0;
        // sort(p[0].begin(),p[0].end());
        //sort  column wise and keep finding the non intersecting pairs
         sort(p.begin(), p.end(), sc);
        int a=p[0][0],b=p[0][1],c=1;
        for(int i=1;i<n;i++)
        {
            // cout<<p[i][0]<<p[i][1]<<" ";
              if(b<p[i][0])
              {
                     c++;
                     a=p[i][0];
                     b=p[i][1];
              }
        }
        return c;
    }
};

other ways : https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000353/c-short-and-easy-code-explained/
             https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000483/easy-c-solution-with-detailed-explanations-time-complexity-analysis/
